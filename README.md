# SysTools - 系统封装部署工具

![SysTools Icon](SysTools.ico)

`SysTools` 是一个基于Python和Tkinter构建的模块化、可扩展的系统封装部署工具。

该工具的核心思想是通过一个主程序动态加载和执行一系列独立的“插件”，每个插件负责完成一项具体的系统配置或软件安装任务。

## 🌟 功能特性

- **插件化架构**：所有功能均通过独立的插件实现，易于开发、维护和分享。
- **MVP 架构**：彻底解耦业务逻辑 (Model)、UI展示 (View) 和事件处理 (Presenter)，代码结构清晰，可维护性极高。
- **自动依赖打包**：通过辅助脚本自动收集所有插件的依赖项，简化了PyInstaller的打包流程。
- **多种运行模式**：
  - **图形用户界面 (GUI)**：提供完整的交互式界面，供用户选择并执行功能。
  - **全自动模式 (`-auto`)**：静默执行所有插件，适用于系统封装的最后阶段。
  - **调试模式**：内置多种调试参数，方便开发者在不实际修改系统的情况下测试插件逻辑和UI流程。
  - **控制台模式 (`-console`)**：为GUI应用附加一个控制台，实时查看详细的运行日志。
- **用户友好的交互**：包含了防窗口闪烁、优雅的加载动画、任务中断等多种提升用户体验的细节。

## 📂 项目结构与文件说明

---

### **核心架构**

- **`main.py`**
  > **角色：启动器 (Launcher)**
  > 这是整个应用程序的入口。它的职责非常纯粹：解析命令行参数以决定运行模式（GUI或自动），创建并“组装”MVP三层架构的核心组件，然后启动应用。它不包含任何业务逻辑或UI代码。

- **`core.py`**
  > **角色：模型 (Model)**
  > 应用程序的“大脑”和“引擎”。它负责所有后台的、非UI的业务逻辑，包括：插件的加载与执行、命令行参数的详细解析、自毁与清理任务、以及管理应用的全局状态（如“是否需要重启”）。它通过回调函数与上层（Presenter）通信，完全不知道UI的存在。

- **`gui_tk.py`**
  > **角色：视图 (View)**
  > 使用 `Tkinter` 库构建的用户界面。这是一个“愚蠢”的视图，它只负责创建和展示窗口、按钮、列表等UI控件。它不知道点击按钮后具体会发生什么，只负责在事件发生时通知 `Presenter`。所有UI的更新都由 `Presenter` 指挥。它可以通过 `GUI_DEBUG_MODE` 开关独立运行以方便UI调试。

- **`presenter.py`**
  > **角色：主持人 (Presenter)**
  > 连接 Model 和 View 的“中枢神经系统”。它监听来自 `gui_tk.py` 的用户操作（如按钮点击），然后向 `core.py` 下达指令；同时，它也监听来自 `core.py` 的后台状态更新（如日志、进度），然后指挥 `gui_tk.py` 更新界面显示。所有的交互逻辑都在这里实现。

---

### **插件系统**

- **`plugins/`**
  > **插件目录**
  > 这是主程序在正常模式下加载功能插件的地方。每个 `.py` 文件都是一个独立的插件“包装器”，负责向主程序提供名称、描述等信息，并定义 `execute` 方法来调用具体的逻辑。

- **`plugins/tools/`**
  > **插件逻辑与资源目录**
  > 存放插件的具体实现逻辑脚本（如 `sample_logic.py`）和它们所需的配置文件（`.ini`）。这种“包装器-逻辑”分离的设计模式，使得复杂的功能可以被独立测试和维护。<br>
  > 当然，你也可以将实现逻辑直接写入插件文件内，也可以在此存放你需要的.exe或其他文件。

- **`plugins/tools/templates/`**
  > **图像识别模板目录**
  > 存放所有插件在进行GUI自动化时，需要用到的模板图像文件（`建议使用.bmp`）。

- **`plugins_test/`**
  > **测试插件目录**
  > 当程序以 `-test` 参数启动时，会加载此目录下的插件。这为开发和测试新插件提供了一个隔离的环境，不会影响主 `plugins` 目录。

- **`plugin_base.py`**
  > **插件基类**
  > 定义了所有插件都必须遵守的“接口约定”（`ABC - Abstract Base Class`）。它规定了每个插件都必须实现 `get_name()`, `get_description()`, `execute()` 等核心方法。

- **`plugin_manager.py`**
  > **插件管理器**
  > 负责动态地发现、加载、验证和排序 `plugins/` 或 `plugins_test/` 目录中的所有插件文件。

---

### **构建与打包**

- **`build.bat`**
  > **自动化打包脚本**
  > 一个强大的批处理脚本，它会自动完成打包一个可发布 `.exe` 所需的所有步骤：清理旧文件 -> 自动收集依赖 -> 调用PyInstaller打包 -> 整理和复制所有必要的文件（插件、配置、图标等）到一个干净的发布文件夹中。

- **`collect_imports.py`**
  > **依赖收集脚本**
  > 这是自动化打包流程的核心。它会自动扫描所有插件和工具脚本，提取所有的 `import` 语句，并生成一个 `_hidden_imports.py` 文件，以确保PyInstaller在打包时不会遗漏任何插件所需的库。

- **`_hidden_imports.py`**
  > **自动生成的依赖文件**
  > 由 `collect_imports.py` 自动生成，被 `main.py` 导入。它的唯一作用就是向PyInstaller“暴露”所有插件的隐藏依赖。**此文件不应手动编辑**。

- **`requirements.txt`**
  > **项目依赖清单**
  > 记录了开发本项目所需的所有第三方Python库。在一个新的开发环境中，只需运行 `pip install -r requirements.txt` 即可快速搭建起与作者完全一致的开发环境。

- **`version_info.txt`**
  > **版本信息文件**
  > 用于在PyInstaller打包时，将详细的版本号、公司名称、版权等信息嵌入到最终生成的 `.exe` 文件的属性中。

- **`00_sample_plugin.py`**
  > **功能演示插件**
  > 用于示例插件的写法。

- **`sample_logic.py`**
  > **功能演示插件的逻辑文件**
  > 创建一个tk窗口，播放动画，及在用户说明下创建一个txt文件。

- **`01_reg_repair.py`**
  > **注册表修复插件**
  > 用于运行 \tools 文件夹下的 reg.ps1 脚本文件，并向gui返回运行结果。

- **`reg.ps1`**
  > **注册表替换脚本**
  > 自动扫描注册表内 C:\Users\Administrator 路径，并将Administrator替换为当前用户名。
---

### **其他文件**

- **`debug_cli.py`**
  > **命令行调试工具**
  > 一个纯命令行的交互界面，直接与 `core.py` 对话。它的存在完美地证明了 `core.py` 是一个可以脱离任何GUI独立运行的引擎，非常适合用于后台逻辑的快速测试和调试。

- **`SysTools.ico`**
  > **应用程序图标**
  > 用于主窗口、所有对话框以及最终打包生成的 `.exe` 文件。

- **`Set_SysTools_RunOnce.reg`**
  > **注册表文件**
  > 一个注册表脚本。双击导入后，它会将本程序添加到Windows的 `RunOnce` 启动项中，使得程序在下次系统启动时能以 `SYSTEM` 高级权限自动运行一次，这对于执行某些需要极高权限的系统级设置非常有用。

## 🚀 快速开始

1.  **创建虚拟环境并安装依赖**
    ```bash
    python -m venv .venv
    .\.venv\Scripts\activate
    pip install -r requirements.txt
    ```

2.  **运行程序**
    *   **GUI模式**:
        ```bash
        python main.py
        ```
    *   **命令行调试模式**:
        ```bash
        python debug_cli.py
        ```

3.  **打包程序**
    ```bash
    .\build.bat
    ```
    打包完成后，所有可分发的文件将位于 `SysTools_FinalPackage/` 文件夹中。